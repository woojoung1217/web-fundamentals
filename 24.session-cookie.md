## 쿠키와 세션 (프론트엔드 관점 정리)

### 왜 필요한가

웹은 기본적으로 상태를 저장하지 않는(stateless) 프로토콜 위에서 동작합니다. 로그인 상태, 장바구니 같은 사용자 맥락을 유지하려면 상태를 어딘가에 저장하고 요청 간에 연결해야 합니다. 대표적인 방식이 쿠키와 세션입니다.

### 쿠키(Cookie)

- **정의**: 브라우저(클라이언트)에 저장되는 작은 키-값 데이터.
- **동작 흐름**:
  1. 서버가 응답 시 `Set-Cookie` 헤더로 쿠키를 설정
  2. 브라우저가 동일 사이트/경로 규칙에 맞으면 요청마다 자동으로 쿠키 전송
- **주요 속성**:
  - `Expires/Max-Age`: 만료 시점(세션 쿠키/지속 쿠키)
  - `Domain/Path`: 전송 범위
  - `Secure`: HTTPS에서만 전송
  - `HttpOnly`: JS로 접근 불가(XSS 완화)
  - `SameSite`: CSRF 완화(Lax/Strict/None+Secure)
- **장점**:
  - 서버 저장소 없이 상태 연속성 유지 가능
  - 요청에 자동 포함되어 인증 연동이 간편
- **단점/주의**:
  - 자동 전송 특성으로 불필요한 트래픽 증가 가능
  - 탈취 시 위험(특히 HttpOnly 미설정, Secure 미사용인 경우)
  - 용량/개수 제한(도메인당 대략 수십 개, 총 수 KB 수준)
  - 민감정보(PII, 크리덴셜) 직접 저장 지양

### 세션(Session)

- **정의**: 사용자 상태를 서버 측 저장소에 보관하고, 클라이언트에는 참조용 세션 ID만 전달하는 방식.
- **동작 흐름**:
  1. 인증 성공 시 서버가 세션 생성 및 `sessionId` 발급
  2. 클라이언트는 이후 요청마다 `sessionId`를 전달(보통 쿠키에 담아 전송)
  3. 서버는 저장소(메모리/Redis/DB 등)에서 상태 조회
- **장점**:
  - 상태가 서버에 있으므로 유출 시 피해 범위가 상대적으로 제한적
  - 서버 주도로 강제 로그아웃, 동시 로그인 제한 등 제어 용이
- **단점/주의**:
  - 서버 자원 사용 및 수평 확장 시 세션 공유/동기화 필요(예: Redis, sticky session)
  - 스테이트풀 아키텍처로 운영 복잡도 증가

### 쿠키 vs Web Storage(localStorage/sessionStorage)

- **자동 전송**: 쿠키는 조건 충족 시 요청에 자동 포함, Web Storage는 자동 전송되지 않음(명시적 전송 필요)
- **보안 특성**: 쿠키는 `HttpOnly`로 XSS 접근 차단 가능, Web Storage는 JS로 접근 가능해 XSS에 더 취약
- **용량/만료**: Web Storage가 용량이 크고 단순, 쿠키는 엄격한 크기/개수 제한과 만료 정책
- **사용 사례**:
  - 인증/세션 식별자: HttpOnly/Secure 쿠키 권장
  - 비민감 UI 상태/캐시: Web Storage 적합

### 인증 설계 권장 패턴(요약)

- **세션 기반**: `sessionId`를 `HttpOnly + Secure + SameSite` 쿠키로 보관, 서버 저장소에 상태 유지
- **토큰 기반**: 리프레시 토큰은 `HttpOnly` 쿠키, 액세스 토큰은 메모리 보관(필요 시 헤더로 전송)
- **CSRF 대응**: `SameSite` 적절 설정 + CSRF 토큰(Double Submit 등) 병행
- **XSS 대응**: 쿠키 `HttpOnly`, 콘텐츠 보안 정책(CSP), 입력 검증

### 세션 방식을 선택하는 경우

- 보안 중요도가 높은 서비스(금융, 사내 시스템 등)
- **원격 로그아웃**/동시 로그인 기기 수 제한 등 서버 주도 제어 필요
- 규정 준수 요구로 서버 측 상태관리 및 감사 추적이 필요한 경우

### 트레이드오프

- 세션은 보안/제어에 유리하지만 서버 비용과 운영 복잡도가 증가
- 쿠키에 상태를 많이 담으면 노출 및 트래픽 부담, 관리 어려움
- 분산 환경에서는 세션 스토리지 중앙화(예: Redis) 또는 토큰 기반으로 전환을 검토

### 체크리스트

- 쿠키: `HttpOnly`, `Secure`, `SameSite` 기본 활성화
- 민감정보는 쿠키/Storage에 직접 저장하지 않기(식별자/토큰만)
- 로그아웃/토큰 무효화 플로우 명확화(서버 삭제, 블랙리스트, 회전)
- 수평 확장 계획: 세션 공유 전략 또는 토큰 전략 사전 결정

쿠키와 세션에 대해 설명해주세요.
프론트엔드와 관련된 질문이에요.
쿠키와 세션은 클라이언트와 서버 간의 상태를 유지하기 위해 사용하는 대표적인 방식들입니다. 웹은 기본적으로 상태를 저장하지 않는 Stateless한 구조이기 때문에, 사용자의 로그인 정보나 장바구니와 같은 클라이언트 정보를 유지하려면 별도의 상태 관리 방식이 필요합니다. 이때 주로 활용되는 방식이 쿠키와 세션입니다.

먼저, 쿠키는 클라이언트 측에 저장되는 데이터입니다. 서버가 클라이언트에게 응답할 때 Set-Cookie 헤더를 통해 데이터를 전달하고, 이후 클라이언트는 요청 시 해당 쿠키를 자동으로 포함하여 서버로 전송하게 됩니다. 쿠키는 브라우저에 저장되기 때문에 서버에서는 별도의 저장 공간을 차지하지 않으며, 지속적인 상태 유지가 가능합니다. 유효 기간을 설정하여 자동 만료되도록 할 수도 있습니다. 쿠키는 클라이언트 측에 상태를 저장하기 때문에 서버는 세션처럼 별도의 저장소를 유지하지 않아도 된다는 장점이 있습니다. 하지만 탈취될 경우 쿠키에 포함된 개인정보가 노출되는 보안 상 단점이 존재합니다.

반면 세션은 서버 측에 저장되는 데이터입니다. 사용자가 서버에 처음 인증을 수행할 때 고유한 세션 ID가 생성되고, 이 ID가 클라이언트에 전달됩니다. 이후 클라이언트는 이 세션 ID를 서버로 전송하며, 서버는 해당 ID를 통해 사용자 상태 정보를 조회합니다. 세션은 서버에 저장되기 때문에 보안 면에서 쿠키보다 안전하지만, 서버 자원을 차지하고 확장에 불리하다는 단점이 있습니다.

쿠키 대신 LocalStorage나 SessionStorage를 사용해도 되지 않나요?
말씀하신대로 LocalStorage와 SessionStorage는 모두 브라우저에 데이터를 저장하는 방식으로, 쿠키와 유사한 점이 있습니다.

하지만 자동으로 서버에 전송되지 않는다는 차이점이 있습니다. 또한, 두 저장소는 자바스크립트를 통해 접근이 가능하므로 XSS에 더욱 취약할 수 있습니다. 반면, 쿠키는 매 요청에 자동으로 포함되며 HttpOnly 설정을 통해 XSS를 예방할 수 있습니다. 따라서 인증 상태를 관리할 때에는 쿠키를 사용하는 경우가 많습니다.

로그인 구현 시 세션 방식은 주로 어떤 경우에 채택하나요?
보안의 중요도가 높은 서비스에서 많이 사용합니다. 세션 ID는 서버에 저장되고 클라이언트에는 참조만 전달되어 토큰 기반 방식보다 탈취 시 위험성이 낮고, 대응에도 용이합니다.

또한, 원격 로그아웃 기능이 필요한 경우에도 사용됩니다. 예를 들어, 동시 로그인 가능 기기 수를 제한해야 하거나, 강제 로그아웃을 구현해야 하는 경우가 있습니다. 이처럼 서버 측에서 사용자별 로그인 상태를 관리해야 하는 경우 유용하게 활용될 수 있습니다.

다만, 서버 자원을 많이 사용하고 분산 시스템에서는 세션 동기화가 필요하다는 단점이 있으므로 트레이드 오프를 고려하여 선택해야 합니다.
